import datetime
import logging
import re
import shlex
import subprocess
from dataclasses import dataclass
from enum import StrEnum
from typing import Literal

from google.api_core import exceptions as gcp_exceptions
from google.api_core.datetime_helpers import DatetimeWithNanoseconds
from google.cloud import artifactregistry_v1
from google.cloud.artifactregistry_v1.types import DockerImage
from google.protobuf.timestamp_pb2 import Timestamp

ar_client = artifactregistry_v1.ArtifactRegistryClient()


# google's python types autogenerated from protobufs have incorrect types
# for the timestamp fields, it says they are a "Timestamp" but they are actually
# a DatetimeWithNanoseconds | None, so need a function to handle the conversion
def image_timestamp_to_datetime(timestamp: Timestamp | DatetimeWithNanoseconds | None):
    if timestamp is None:
        return None
    return datetime.datetime.fromisoformat(str(timestamp))


@dataclass
class Image:
    full_path: str
    build_time: datetime.datetime | None
    update_time: datetime.datetime | None
    upload_time: datetime.datetime | None
    size_bytes: int
    tags: list[str]
    digest: str
    project: str
    location: str
    repository: str
    name: str

    @property
    def status(self) -> Literal['active', 'archived']:
        return 'archived' if self.repository.endswith('-archive') else 'active'

    @property
    def short_path(self):
        return f'{self.repository}/{self.name}'

    @property
    def version_id(self):
        return f'{self.short_path}@sha256:{self.digest}'

    @property
    def docker_name(self):
        return f'{self.location}-docker.pkg.dev/{self.project}/{self.repository}/{self.name}@sha256:{self.digest}'

    @property
    def gcp_repository_resource_name(self):
        return f'projects/{self.project}/locations/{self.location}/repositories/{self.repository}'

    @property
    def gcp_package_resource_name(self):
        return f'{self.gcp_repository_resource_name}/packages/{self.name}'

    @property
    def gcp_version_resource_name(self):
        return f'{self.gcp_package_resource_name}/versions/sha256:{self.digest}'

    def get_gcp_tag_resource_name(self, tag: str):
        return f'projects/{self.project}/locations/{self.location}/entrygroups/{self.repository}/entries/{self.digest}/tags/{tag}'

    def get_gcp_tag_resource_name_for_delete(self, tag: str):
        return f'{self.gcp_package_resource_name}/tags/{tag}'

    # Compute what some paths would have been before image was archived
    # This is useful for comparing image versions across archived and non-archived
    # repositories.
    @property
    def active_full_path(self):
        return self.full_path.replace('-archive/dockerImages', '/dockerImages')

    @property
    def active_repository(self):
        return self.repository.removesuffix('-archive')

    @property
    def active_short_path(self):
        return f'{self.active_repository}/{self.name}'

    @property
    def active_version_id(self):
        return f'{self.active_short_path}@sha256:{self.digest}'

    @property
    def active_docker_name(self):
        return f'{self.location}-docker.pkg.dev/{self.project}/{self.active_repository}/{self.name}@sha256:{self.digest}'

    # Compute what some paths would look like after the image is archived
    # This is useful when moving images back and forth between archived and active
    @property
    def archived_full_path(self):
        return (
            self.full_path.replace('/dockerImages', '-archive/dockerImages')
            if '-archive/dockerImages' not in self.full_path
            else self.full_path
        )

    @property
    def archived_repository(self):
        return (
            f'{self.repository}-archive'
            if not self.repository.endswith('-archive')
            else self.repository
        )

    @property
    def archived_short_path(self):
        return f'{self.archived_repository}/{self.name}'

    @property
    def archived_version_id(self):
        return f'{self.archived_short_path}@sha256:{self.digest}'

    @property
    def archived_docker_name(self):
        repository = self.archived_repository
        return f'{self.location}-docker.pkg.dev/{self.project}/{repository}/{self.name}@sha256:{self.digest}'

    def convert_to_active(self):
        "Get a version of the image tas if it were active"
        return Image(
            full_path=self.active_full_path,
            build_time=self.build_time,
            update_time=self.update_time,
            upload_time=self.upload_time,
            size_bytes=self.size_bytes,
            tags=self.tags,
            digest=self.digest,
            project=self.project,
            location=self.location,
            repository=self.active_repository,
            name=self.name,
        )

    def convert_to_archived(self):
        "Get a version of the image as if it were archived"
        return Image(
            full_path=self.archived_full_path,
            build_time=self.build_time,
            update_time=self.update_time,
            upload_time=self.upload_time,
            size_bytes=self.size_bytes,
            tags=self.tags,
            digest=self.digest,
            project=self.project,
            location=self.location,
            repository=self.archived_repository,
            name=self.name,
        )

    @staticmethod
    def from_artifact_repository_image(image_data: DockerImage) -> 'Image':
        """
        Given a DockerImage object, create a new Image object.
        """
        image_path = image_data.name.replace('%2F', '/')

        name_match = re.search(
            'projects/([^/]+)/locations/([^/]+)/repositories/([^/]+)/dockerImages/([^@]+)@sha256:(.+)$',
            image_path,
        )

        if not name_match:
            raise ValueError(f'Invalid image path: {image_path}')

        project = name_match[1]
        location = name_match[2]
        repository = name_match[3]
        name = name_match[4]
        digest = name_match[5]

        # Validate that info was pulled from the image path successfully
        if not (
            type(project) is str
            and type(location) is str
            and type(repository) is str
            and type(name) is str
            and type(digest) is str
        ):
            raise ValueError(f'Invalid image path: {image_path}')

        return Image(
            full_path=image_path,
            build_time=image_timestamp_to_datetime(image_data.build_time),
            update_time=image_timestamp_to_datetime(image_data.update_time),
            upload_time=image_timestamp_to_datetime(image_data.upload_time),
            size_bytes=image_data.image_size_bytes,
            # Filter out digest from tags, no need to double up on it
            tags=[l for l in list(image_data.tags) if l != digest],
            digest=digest,
            project=project,
            location=location,
            repository=repository,
            name=name,
        )


@dataclass
class Repository:
    images: list[Image]

    def includes_image_version(self, image: Image):
        """
        Check if this repository already has a certain version of an image
        """
        matching_images = [
            i for i in self.images if i.name == image.name and i.digest == image.digest
        ]
        return len(matching_images) > 0

    def find_conflicting_tags(self, image: Image):
        """
        Check if there are any other images in the repository with the same
        name and same tags but different digest
        """
        conflicting_tags: set[str] = set()

        for i in self.images:
            if i.name == image.name and i.digest != image.digest:
                conflicting_tags.update(set(i.tags) & set(image.tags))

        return list(conflicting_tags)


def list_images_in_repository(repository: str):
    """
    Get a list of all images in the specifiec repository.
    returns a list of Image dataclass instances
    """

    request = artifactregistry_v1.ListDockerImagesRequest(
        parent=f'projects/cpg-common/locations/australia-southeast1/repositories/{repository}',
    )

    page_result = ar_client.list_docker_images(request=request)
    return [Image.from_artifact_repository_image(response) for response in page_result]


def copy_image(source: str, destination: str):
    """
    Copies an image from `source` to `destination` using skopeo.
    """

    try:
        # Copy the image from the source repo to the destination. This doesn't need
        # to check if it already exists as skopeo won't do anything if the image is
        # already there, and it is pretty much as quick as running an additional check
        logging.info(f'Copying image from {source} to {destination} using skopeo...')

        subprocess.run(  # noqa: S603 - shlex escapes the command, linter just can't tell
            shlex.split(
                f'skopeo copy --all --preserve-digests docker://{source} docker://{destination}'
            ),
            check=True,
        )

        logging.info(f'Image successfully copied from {source} to {destination}.')

    except subprocess.CalledProcessError as e:
        raise Exception(f'Error occurred while copying image with skopeo: {e}') from e


def add_tag(image: Image, tag: str):
    try:
        logging.info(f'Adding tag {tag} to image {image.version_id}')
        # Create the request to add the tag
        request = artifactregistry_v1.CreateTagRequest(
            parent=image.gcp_package_resource_name,
            tag_id=tag,
            tag=artifactregistry_v1.Tag(
                name=image.get_gcp_tag_resource_name(tag),
                version=image.gcp_version_resource_name,
            ),
        )

        ar_client.create_tag(request=request)

        logging.info(f'Successfully added tag {tag} to image {image.version_id}')
    except gcp_exceptions.AlreadyExists as already_exists_err:
        logging.warning(
            f'Tag {tag} already exists for image {image.version_id}: {already_exists_err}'
        )
    except Exception as e:
        logging.error(f'Failed to add tag {tag} to image {image.version_id}: {e}')
        raise e


def add_tags(image: Image, tags: list[str]):
    "Add tags to an existing image"
    for tag in tags:
        add_tag(image, tag)


class DeleteVersionStatus(StrEnum):
    SUCCESS = 'success'
    FAILED_PRECONDITION = 'failed_precondition'


def delete_version(image: Image):
    "Delete an image version"

    try:
        request = artifactregistry_v1.DeleteVersionRequest(
            name=image.gcp_version_resource_name,
            force=True,  # delete even if it is tagged
        )
        ar_client.delete_version(request=request).result()

        logging.info(f'Successfully deleted image: {image.version_id}')
        return DeleteVersionStatus.SUCCESS
    except gcp_exceptions.FailedPrecondition as failed_precondition_err:
        # https://cloud.google.com/sdk/gcloud/reference/artifacts/versions/delete
        # This FailedPrecondition error can happen for a number of reasons, but in our
        # case the most likely is that the image is referenced by another manifest
        # in this case we don't want to move the image as it is still "in use"
        logging.warning(
            f'Image {image.version_id} failed precondition check: {failed_precondition_err}'
        )
        return DeleteVersionStatus.FAILED_PRECONDITION
    except Exception as e:
        logging.error(f'Failed to delete image {image.version_id}: {e}')
        raise e


def version_exists(image: Image):
    try:
        request = artifactregistry_v1.GetVersionRequest(
            name=image.gcp_version_resource_name,
        )
        ar_client.get_version(request=request)
        return True
    except gcp_exceptions.NotFound:
        return False
